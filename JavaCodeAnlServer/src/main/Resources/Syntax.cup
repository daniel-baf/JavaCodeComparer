
/***************************************/
/********** USER CODE SECTION **********/
/***************************************/

package Backend.Objects.Parsers;
import java_cup.runtime.*;
import Backend.Objects.Lexers.JavaCodeLexer;

/* Preliminaries to set up and use the scanner.  */
parser code {:

  int counter = 0;

    // constructor
    public JavaCodeParser(JavaCodeLexer lexer) {
        super(lexer);
    }

    /* ERRORS METHOD */
    public void report_error(String message, Object info) {
        System.out.println("public void report_error");
    }
    
    public void report_fatal_error(String message, Object info) {
        System.out.println("public void report_fatal_error");
    }

    public void syntax_error(Symbol cur_token) {
        System.out.println("Error en simbolo: " + sym.terminalNames[cur_token.sym] + " L:" + cur_token.left + " C:" +  cur_token.right);
    }

    public void unrecovered_syntax_error(Symbol cur_token) {
        System.out.println("UNrecovered syntax error");
    }

    public void printK(String message) {
        System.out.println((counter + 1) + ":" + "::" + cur_token.left + "(" + cur_token.right + ") ->" + message);
        counter++;
    }
:}

/**************************************/
/********** TERMINAL SECTION **********/
/**************************************/
// from lexer
// symbols
terminal INC, DEC, PLUS_T, LESS_T, MULT_T, DIV_T, AND, OR, GE, GT, LE, LT, EQ, NE, DOT, STAR, PLUS, MINUS,
    DIV, MOD, COMMA, PAR_OPEN, PAR_CLOSE, NOT, SEMICOLON, ASSIGN, BRAC_OPEN, BRAC_CLOSE, COLON, UNKNOWN;
// elements
terminal ID, VAR_TYPE, NUMBER, DECIMAL,VAL_COMILLAS,CHAR,TRUE,FALSE, NEW, RETURN, BREAK, VISIBILITY, FINAL, STATIC;
// methods
terminal IF, ELSE, FOR, WHILE, DO, SWITCH, CASE, DEFAULT, FUNC_TYPE, CLASS, PACKAGE, IMPORT;

// symbols
non terminal sym_conc_bool, sym_inc_asgn, sym_inc_step, sym_compare, sym_arithm, var_type0;
// items
non terminal id_item, element;
// methods
non terminal vals_receive, var_with_type, val_declaration_asgn, new_object_asgn, vals_send, bool_compare, bool_compare_sub, 
    output_sentence, output_actions, var_assign, var_assign_act, var_declaration, var_declaration_sub, var_declaration_sub_extra,
    function_content, if_structure, function_part, function_parts, for_structure, for_par_content, while_structure, switch_structure,
    switch_content, case_section, case_content, constructor_structure, par_receive_vals, method_structure, non_constructor_structure,
    method_structure_sub, method_call_structure, for_validation, functions_methods;
// class
non terminal class_content, class_content_sub, class_structure, class_structure_sub, file,  package_structure, class_data, class_data_sub,
    import_structure;

// math
non terminal arithm_expr;


precedence left PLUS, MINUS;
precedence left DIV, MOD, STAR;
precedence left PAR_OPEN, PAR_CLOSE;

start with file;

file::=
    package_structure class_data
  | class_data
;

class_data::=
    class_data_sub
  | class_data class_data_sub
;

class_data_sub::=
    import_structure
  | class_structure
  | error class_data_sub
;

// package
package_structure::=
  PACKAGE id_item SEMICOLON                 {: printK("package delcared"); :}
;

// import
import_structure::=
    IMPORT id_item SEMICOLON                {: printK("import delcared"); :}
  | IMPORT id_item DOT STAR SEMICOLON       {: printK("import delcared, star"); :}
;

// class
class_structure::=
    class_structure_sub                 {: printK("class delcared"); :}
  | VISIBILITY class_structure_sub      {: printK("class delcared"); :}
;

class_structure_sub::=
    CLASS ID BRAC_OPEN BRAC_CLOSE
  | CLASS ID BRAC_OPEN class_content BRAC_CLOSE
;

class_content::=
    class_content_sub
  | class_content class_content_sub
;

class_content_sub::=
    method_structure
  | var_declaration             {: printK("class declared: variable"); :}
;

// method declaration
method_structure::=
    method_structure_sub
  | VISIBILITY method_structure_sub
;

method_structure_sub::=
    constructor_structure:DATA
      {:
        RESULT = DATA;
        printK("method delcared, constructor"); 
      :}
  | non_constructor_structure       {: printK("method delcared, method"); :}
;

non_constructor_structure::=
    FUNC_TYPE constructor_structure
  | var_type0 constructor_structure
;

constructor_structure::=
    ID par_receive_vals function_content
  | error function_content
;

// method common
function_content::=
    BRAC_OPEN BRAC_CLOSE
  | BRAC_OPEN function_parts BRAC_CLOSE
;

function_parts::=
    function_part
  | function_parts function_part
;

function_part::=
    var_declaration_sub       {: printK("variable declaration"); :}
  | var_assign                {: printK("variable assgination"); :}
  | output_sentence           {: printK("output sentence"); :}
  | method_call_structure     {: printK("method call"); :}
  | functions_methods
;

functions_methods::=
    if_structure              {: printK("if declaration"); :}
  | for_structure             {: printK("for declaration"); :}
  | while_structure           {: printK("while/do while declaration"); :}
  | switch_structure          {: printK("switch declaration"); :}
  | error function_content
;

method_call_structure::=
    id_item PAR_OPEN PAR_CLOSE SEMICOLON
  | id_item PAR_OPEN vals_send PAR_CLOSE SEMICOLON
;

// methods structures
switch_structure::=
    SWITCH PAR_OPEN element PAR_CLOSE BRAC_OPEN switch_content BRAC_CLOSE
  | error BRAC_CLOSE
;

switch_content::=
    case_section
  | switch_content case_section
;

case_section::=
    CASE element case_content
  | DEFAULT case_content
;

case_content::=
    COLON
  | COLON function_parts
;

while_structure::=
    WHILE PAR_OPEN bool_compare PAR_CLOSE function_content
  | DO function_content WHILE PAR_OPEN bool_compare PAR_CLOSE SEMICOLON
;


for_structure::=
  FOR PAR_OPEN for_par_content PAR_CLOSE function_content
;

for_par_content::=
    VAR_TYPE for_validation SEMICOLON for_validation SEMICOLON ID sym_inc_step
  | VAR_TYPE for_validation SEMICOLON for_validation SEMICOLON ID sym_inc_asgn arithm_expr
;

for_validation::=
    ID ASSIGN arithm_expr
  | ID sym_compare arithm_expr
;



if_structure::=
    IF PAR_OPEN bool_compare PAR_CLOSE function_content
  | IF PAR_OPEN bool_compare PAR_CLOSE function_content ELSE function_content
;


// into methods
par_receive_vals::=
    PAR_OPEN vals_receive PAR_CLOSE
  | PAR_OPEN PAR_CLOSE
;


var_declaration::=
    var_declaration_sub
  | VISIBILITY var_declaration_sub
;

var_declaration_sub::=
    var_declaration_sub_extra             
  | FINAL var_declaration_sub_extra       
  | STATIC var_declaration_sub_extra      
  | STATIC FINAL var_declaration_sub_extra
;

var_declaration_sub_extra::=
    var_type0 var_assign
  | var_type0 id_item SEMICOLON
  | error SEMICOLON
;

var_assign::=
  id_item var_assign_act SEMICOLON
;

var_assign_act::=
    ASSIGN val_declaration_asgn               
  | sym_inc_asgn arithm_expr                  
  | sym_inc_step                              
;

output_sentence::=
    BREAK SEMICOLON                
  | RETURN SEMICOLON               
  | RETURN output_actions SEMICOLON
;

output_actions::=
  bool_compare
;

bool_compare::=
    bool_compare_sub                              {: printK("bool compare"); :}
  | bool_compare sym_conc_bool bool_compare_sub
;

bool_compare_sub::=
    arithm_expr
  | arithm_expr sym_compare arithm_expr
  | NOT PAR_OPEN bool_compare_sub PAR_CLOSE
;

vals_send::=
    val_declaration_asgn                    {: printK("params send"); :}
  | vals_send COMMA val_declaration_asgn
;

vals_receive::=
    var_with_type                         {: printK("params receive"); :}
  | vals_receive COMMA var_with_type
;

val_declaration_asgn::=
    arithm_expr
  | new_object_asgn
;

new_object_asgn::=
    NEW ID PAR_OPEN PAR_CLOSE
  | NEW ID PAR_OPEN vals_send PAR_CLOSE
;

var_with_type::= 
  var_type0 ID
;

arithm_expr::=
    element
  | arithm_expr sym_arithm arithm_expr
  | PAR_OPEN arithm_expr PAR_CLOSE
;

element::=
    NUMBER      
  | DECIMAL     
  | VAL_COMILLAS
  | CHAR        
  | TRUE        
  | FALSE       
  | id_item     
;

id_item::= // catch multiple ids as k or k.a or k.b.c...
    ID
  | id_item DOT ID
;

var_type0::= // the type of the variables
    VAR_TYPE
  | ID      
;

sym_arithm::=
    PLUS 
  | MINUS
  | DIV  
  | MOD  
  | STAR 
;

sym_compare::=
    GE
  | GT
  | LE
  | LT
  | EQ
  | NE
;

sym_inc_step::=
    INC
  | DEC
;

sym_inc_asgn::=
    PLUS_T
  | LESS_T
  | MULT_T 
  | DIV_T 
;

sym_conc_bool::=
    AND
  | OR 
;