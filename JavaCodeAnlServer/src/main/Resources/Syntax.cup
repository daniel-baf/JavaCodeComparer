
/***************************************/
/********** USER CODE SECTION **********/
/***************************************/

package Backend.Objects.Parsers;
import java_cup.runtime.*;
import Backend.Objects.Lexers.JavaCodeLexer;
import Backend.Objects.NodeTree.*;
import java.util.ArrayList;

/* Preliminaries to set up and use the scanner.  */
parser code {:

  int counter = 0;
  TreeActioner tree;

  // constructor
  public JavaCodeParser(JavaCodeLexer lexer) {
    super(lexer);
    counter = 0;
    tree = new TreeActioner();
  }

  /* ERRORS METHOD */
  public void report_error(String message, Object info) {
      System.out.println("public void report_error");
  }
  
  public void report_fatal_error(String message, Object info) {
      System.out.println("public void report_fatal_error");
  }

  public void syntax_error(Symbol cur_token) {
      System.out.println("Error en simbolo: " + sym.terminalNames[cur_token.sym] + " L:" + cur_token.left + " C:" +  cur_token.right);
  }

  public void unrecovered_syntax_error(Symbol cur_token) {
      System.out.println("UNrecovered syntax error");
  }

  public void printK(String message) {
      System.out.println((counter + 1) + ":" + "::" + cur_token.left + "(" + cur_token.right + ") ->" + message);
      counter++;
  }
:}

/**************************************/
/********** TERMINAL SECTION **********/
/**************************************/
// from lexer
// symbols
terminal INC, DEC, PLUS_T, LESS_T, MULT_T, DIV_T, AND, OR, GE, GT, LE, LT, EQ, NE, DOT, STAR, PLUS, MINUS,
    DIV, MOD, COMMA, PAR_OPEN, PAR_CLOSE, NOT, SEMICOLON, ASSIGN, BRAC_OPEN, BRAC_CLOSE, COLON, UNKNOWN;
// elements
terminal ID, VAR_TYPE, NUMBER, DECIMAL,VAL_COMILLAS,CHAR,TRUE,FALSE, NEW, RETURN, BREAK, VISIBILITY, FINAL, STATIC;
// methods
terminal IF, ELSE, FOR, WHILE, DO, SWITCH, CASE, DEFAULT, FUNC_TYPE, CLASS, PACKAGE, IMPORT;

// symbols
non terminal sym_conc_bool, sym_inc_asgn, sym_inc_step, sym_compare, sym_arithm, var_type0;
// items
non terminal id_item, element;
// methods
non terminal vals_receive, var_with_type, val_declaration_asgn, new_object_asgn, vals_send, bool_compare, bool_compare_sub, 
    output_sentence, output_actions, var_assign, var_assign_act, var_declaration, var_declaration_sub, var_declaration_sub_extra,
    function_content, if_structure, function_part, function_parts, for_structure, for_par_content, while_structure, switch_structure,
    switch_content, case_section, case_content, constructor_structure, par_receive_vals, method_structure, non_constructor_structure,
    method_structure_sub, method_call_structure, for_validation, functions_methods;
// class
non terminal class_content, class_content_sub, class_structure, class_structure_sub, file,  package_structure, class_data, class_data_sub,
    import_structure;

// math
non terminal arithm_expr;


precedence left PLUS, MINUS;
precedence left DIV, MOD, STAR;
precedence left PAR_OPEN, PAR_CLOSE;

start with file;

file::=
    package_structure class_data
  | class_data
;

class_data::=
    class_data_sub
  | class_data class_data_sub
;

class_data_sub::=
    import_structure
  | class_structure
  | error class_data_sub
;

// package
package_structure::=
  PACKAGE id_item SEMICOLON                 {: printK("package delcared"); :}
;

// import
import_structure::=
    IMPORT id_item SEMICOLON                {: printK("import delcared"); :}
  | IMPORT id_item DOT STAR SEMICOLON       {: printK("import delcared, star"); :}
;

// class
class_structure::=
    class_structure_sub                 {: printK("class delcared"); :}
  | VISIBILITY class_structure_sub      {: printK("class delcared"); :}
;

class_structure_sub::=
    CLASS ID BRAC_OPEN BRAC_CLOSE
  | CLASS ID BRAC_OPEN class_content BRAC_CLOSE
;

class_content::=
    class_content_sub
  | class_content class_content_sub
;

class_content_sub::=
    method_structure
  | var_declaration:nodeDecl {: printK("class declared: variable"); :}
;

// method declaration
method_structure::=
    method_structure_sub
  | VISIBILITY method_structure_sub
;

method_structure_sub::=
    constructor_structure           {: printK("method delcared, constructor"); :}
  | non_constructor_structure       {: printK("method delcared, method"); :}
;

non_constructor_structure::=
    FUNC_TYPE constructor_structure:childNodes
  | var_type0 constructor_structure:childNodes
;

constructor_structure::=
    ID par_receive_vals function_content:childNodes 
      {: 
        ArrayList<Node> nodes = (ArrayList<Node>) childNodes;
        try{
          System.out.println("Add nodes to parent: " + nodes.size());
        } catch(Exception e) {
          e.printStackTrace();
        }

      :}
  | error function_content:childNodes      {: RESULT = childNodes; :}
;

// method common
function_content::=
    BRAC_OPEN BRAC_CLOSE                            {: RESULT = null; :}
  | BRAC_OPEN function_parts:childNodes BRAC_CLOSE  {: RESULT = childNodes; :}
;

function_parts::=
    function_part:childNodes      {: RESULT = childNodes; :}
  | function_parts:prevChildNodes function_part:childNodes
    {:
      ArrayList<Node> newNodes = (ArrayList<Node>) childNodes;
      ArrayList<Node> oldNodes = (ArrayList<Node>) prevChildNodes;
      newNodes.addAll(oldNodes);
      RESULT = newNodes;
    :}
;

function_part::=
    var_declaration_sub:nodeDecl    {: RESULT = new ArrayList<Node>().add((Node) nodeDecl); printK("variable declaration");:}
  | var_assign                      {: printK("variable assgination"); :}
  | output_sentence                 {: printK("output sentence"); :}
  | method_call_structure           {: printK("method call"); :}
  | functions_methods:childNodes    {: RESULT = childNodes; :}
;

functions_methods::=
    if_structure:childNodes              {: printK("if declaration"); RESULT = childNodes; :}
  | for_structure:childNodes             {: printK("for declaration"); RESULT = childNodes; :}
  | while_structure:childNodes           {: printK("while/do while declaration"); RESULT = childNodes; :}
  | switch_structure:childNodes          {: printK("switch declaration"); RESULT = childNodes; :}
  | error function_content:childNodes {: RESULT = childNodes; :}
;

method_call_structure::=
    id_item PAR_OPEN PAR_CLOSE SEMICOLON
  | id_item PAR_OPEN vals_send PAR_CLOSE SEMICOLON
;

// methods structures
switch_structure::=
    SWITCH PAR_OPEN element PAR_CLOSE BRAC_OPEN switch_content:childNodes BRAC_CLOSE {: RESULT = childNodes; :}
  | error BRAC_CLOSE
;

switch_content::=
    case_section:childNodes  {: RESULT = childNodes; :}
  | switch_content:prevChildNodes case_section:childNodes
    {:
      ArrayList<Node> newNodes = (ArrayList<Node>) childNodes;
      ArrayList<Node> oldNodes = (ArrayList<Node>) prevChildNodes;
      newNodes.addAll(oldNodes);
      RESULT = newNodes;
    :}
;

case_section::=
    CASE element case_content:childNodes {: RESULT = childNodes; :}
  | DEFAULT case_content:childNodes      {: RESULT = childNodes; :}
;

case_content::=
    COLON
  | COLON function_parts:childNodes {: RESULT = childNodes; :}
;

while_structure::=
    WHILE PAR_OPEN bool_compare PAR_CLOSE function_content:childNodes {: RESULT = childNodes; :}
  | DO function_content:childNodes WHILE PAR_OPEN bool_compare PAR_CLOSE SEMICOLON {: RESULT = childNodes; :}
;


for_structure::=
  FOR PAR_OPEN for_par_content PAR_CLOSE function_content:childNodes
;

for_par_content::=
    VAR_TYPE for_validation SEMICOLON for_validation SEMICOLON ID sym_inc_step
  | VAR_TYPE for_validation SEMICOLON for_validation SEMICOLON ID sym_inc_asgn arithm_expr
;

for_validation::=
    ID ASSIGN arithm_expr
  | ID sym_compare arithm_expr
;



if_structure::=
    IF PAR_OPEN bool_compare PAR_CLOSE function_content:childNodes  {: RESULT = childNodes; :}
  | IF PAR_OPEN bool_compare PAR_CLOSE function_content:childNodes ELSE function_content:extraChildNodes
      {:
        ArrayList<Node> mergedChildNodes = (ArrayList<Node>) childNodes;
        mergedChildNodes.addAll((ArrayList<Node>) extraChildNodes);
        RESULT = mergedChildNodes;
      :}
;


// into methods
par_receive_vals::=
    PAR_OPEN vals_receive PAR_CLOSE
  | PAR_OPEN PAR_CLOSE
;


var_declaration::=
    var_declaration_sub:declNode      {: RESULT = declNode; :}
  | VISIBILITY:visib var_declaration_sub:declNode
    {: 
      Node decNode = (Node) declNode;
      decNode.addAttributes(visib.toString().toUpperCase()); 
      RESULT = decNode;  
    :}
;

var_declaration_sub::=
    var_declaration_sub_extra:declNode            {: RESULT = declNode; :}
  | FINAL var_declaration_sub_extra:declNode
    {:
      Node decNode = (Node) declNode;
      decNode.addAttributes("FINAL"); 
      RESULT = decNode; 
    :}
  | STATIC var_declaration_sub_extra:declNode
    {:
      Node decNode = (Node) declNode;
      decNode.addAttributes("STATIC"); 
      RESULT = declNode;
    :}
  | STATIC FINAL var_declaration_sub_extra:declNode
    {:
      Node decNode = (Node) declNode;
      decNode.addAttributes("STATIC", "FINAL"); 
      RESULT = declNode;
    :}
;

var_declaration_sub_extra::=
    var_type0:TYPE var_assign:ITEM            {: RESULT = new Node(TYPE.toString(),ITEM.toString(),null); :}
  | var_type0:TYPE id_item:ITEM SEMICOLON     {: RESULT = new Node(TYPE.toString(),ITEM.toString(),null); :}
  | error SEMICOLON
;

var_assign::=
  id_item:ITEM var_assign_act SEMICOLON {: RESULT = ITEM.toString(); :}
;

var_assign_act::=
    ASSIGN val_declaration_asgn               
  | sym_inc_asgn arithm_expr                  
  | sym_inc_step                              
;

output_sentence::=
    BREAK SEMICOLON                
  | RETURN SEMICOLON               
  | RETURN output_actions SEMICOLON
;

output_actions::=
  bool_compare
;

bool_compare::=
    bool_compare_sub                              {: printK("bool compare"); :}
  | bool_compare sym_conc_bool bool_compare_sub
;

bool_compare_sub::=
    arithm_expr
  | arithm_expr sym_compare arithm_expr
  | NOT PAR_OPEN bool_compare_sub PAR_CLOSE
;

vals_send::=
    val_declaration_asgn                    {: printK("params send"); :}
  | vals_send COMMA val_declaration_asgn
;

vals_receive::=
    var_with_type                         {: printK("params receive"); :}
  | vals_receive COMMA var_with_type
;

val_declaration_asgn::=
    arithm_expr
  | new_object_asgn
;

new_object_asgn::=
    NEW ID PAR_OPEN PAR_CLOSE
  | NEW ID PAR_OPEN vals_send PAR_CLOSE
;

var_with_type::= 
  var_type0 ID
;

arithm_expr::=
    element
  | arithm_expr sym_arithm arithm_expr
  | PAR_OPEN arithm_expr PAR_CLOSE
;

element::=
    NUMBER      
  | DECIMAL     
  | VAL_COMILLAS
  | CHAR        
  | TRUE        
  | FALSE       
  | id_item     
;

id_item::= // catch multiple ids as k or k.a or k.b.c...
    ID:idVal                      {: RESULT =  idVal.toString(); :}
  | id_item:lastID DOT ID:idVal   
    {: 
      String item =  idVal.toString(); 
      String newItem = lastID + "." + item;
      RESULT = newItem;
    :}
;

var_type0::= // the type of the variables
    VAR_TYPE:type  {: RESULT = type.toString(); :}
  | ID:type        {: RESULT = type.toString(); :}
;

sym_arithm::=
    PLUS 
  | MINUS
  | DIV  
  | MOD  
  | STAR 
;

sym_compare::=
    GE
  | GT
  | LE
  | LT
  | EQ
  | NE
;

sym_inc_step::=
    INC
  | DEC
;

sym_inc_asgn::=
    PLUS_T
  | LESS_T
  | MULT_T 
  | DIV_T 
;

sym_conc_bool::=
    AND
  | OR 
;